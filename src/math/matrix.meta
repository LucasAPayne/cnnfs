#include "../util/types.h"
#include "vector.h"

#include <stdio.h>
#include <stdlib.h>

struct mat
{
    rows: usize;
    cols: usize;
    data: @array(rows + cols) numeric;
};

@api_iface_begin

mat mat_init(usize rows, usize cols, numeric* data);
mat mat_zeros(usize rows, usize cols);

// Set values of a matrix row or column with same-size vector
void mat_set_row(mat* m, vec v, usize row);
void mat_set_col(mat* m, vec v, usize col);

// Set a range of values within a row or column of a matrix
void mat_set_row_range(mat* m, vec v, usize row, usize row_offset);
void mat_set_col_range(mat* m, vec v, usize col, usize col_offset);

void mat_print(mat m);

mat mat_scale(mat m, numeric value);

mat mat_add(mat a, mat b);
mat mat_mul(mat a, mat b);

// Element-wise (Hadamard) product
// Matrices must be equal size
mat mat_had(mat a, mat b);
@api_iface_end

@api_impl_begin
// Return value of matrix at (row,col)
@inline
numeric mat_at(mat m, usize row, usize col)
{
    return m.data[m.cols*row + col];
}

// Set value of matrix at (row,col)
@inline void mat_set_val(mat* m, usize row, usize col, numeric val)
{
    m->data[m->cols*row + col] = val;
}

mat mat_init(usize rows, usize cols, numeric* data)
{
    mat result = {0};
    result.rows = rows;
    result.cols = cols;
    result.data = data;

    return result;
}

mat mat_zeros(usize rows, usize cols)
{
    mat result = {0};
    result.rows = rows;
    result.cols = cols;

    result.data = calloc(rows*cols, sizeof(numeric));
    ASSERT(result.data);

    return result;
}

mat mat_full(usize rows, usize cols, numeric fill_value)
{
    mat m = mat_zeros(rows, cols);

    for (usize row = 0; row < m.rows; ++row)
    {
        for (usize col = 0; col < m.cols; ++col)
            mat_set_val(&m, row, col, fill_value);
    }

    return m;
}

void mat_set_row(mat* m, vec v, usize row)
{
    // To set a row, the vector must have the same number of elements as
    // the matrix has columns
    ASSERT(m->cols == v.elements);

    for (usize col = 0; col < m->cols; ++col)
        mat_set_val(m, row, col, v.data[col]);
}

void mat_set_col(mat* m, vec v, usize col)
{
    // To set a column, the vector must have the same number of elements as
    // the matrix has rows
    ASSERT(m->rows == v.elements);

    for (usize row = 0; row < m->rows; ++row)
        mat_set_val(m, row, col, v.data[row]);
}

void mat_set_row_range(mat* m, vec v, usize row, usize row_offset)
{
    // There must be enough columns after the offset to accommodate the vector
    ASSERT(m->cols >= v.elements + row_offset);

    for (usize i = 0; i < v.elements; ++i)
        mat_set_val(m, row, row_offset + i, v.data[i]);
}

void mat_set_col_range(mat* m, vec v, usize col, usize col_offset)
{
    // There must be enough rows after the offset to accommodate the vector
    ASSERT(m->rows >= v.elements + col_offset);

    for (usize i = 0; i < v.elements; ++i)
        mat_set_val(m, col_offset + i, col, v.data[i]);
}

void mat_print(mat m)
{
    int width = 0;

    // Compute max width needed
    for (usize row = 0; row < m.rows; ++row)
    {
        for (usize col = 0; col < m.cols; ++col)
        {
            int w = snprintf(NULL, 0, "%num", mat_at(m, row, col));
            if (width < w)
                width = w;
        }
    }

    // Print
    printf("[");
    for (usize row = 0; row < m.rows; ++row)
    {
        printf("[");
        for (usize col = 0; col < m.cols; ++col)
        {
            if (col != 0) printf(", ");
            printf("%*num", width, mat_at(m, row, col));
        }
        printf("]");

        if (row < m.rows - 1)
            printf(",\n");
    }
    printf("]");
}

mat mat_scale(mat m, numeric value)
{
    mat result = mat_zeros(m.rows, m.cols);

    for (usize row = 0; row < m.rows; ++row)
    {
        for (usize col = 0; col < m.cols; ++col)
        {
            numeric element = mat_at(m, row, col);
            mat_set_val(&result, row, col, element*value);
        }
    }

    return result;
}

// Stretch a row vector to be matrix with the same shape as target
// by copying the original row a number of times
@internal mat mat_stretch_cols(mat orig, mat target)
{
    // The original matrix must have the same number of columns as the target matrix
    ASSERT(orig.rows == target.rows);
    mat result = mat_zeros(target.rows, target.cols);
    for (usize i = 0; i < target.rows; ++i)
    {
        for (usize j = 0; j < target.cols; ++j)
        {
            numeric val = mat_at(orig, i, 0);
            mat_set_val(&result, i, j, val);
        }
    }

    return result;
}

// Stretch a column vector to be matrix with the same shape as target
// by copying the original column a number of times
@internal mat mat_stretch_rows(mat orig, mat target)
{
    // The original matrix must have the same number of rows as the target matrix
    ASSERT(orig.cols == target.cols);
    mat result = mat_zeros(target.rows, target.cols);
    for (usize i = 0; i < target.rows; ++i)
    {
        for (usize j = 0; j < target.cols; ++j)
        {
            numeric val = mat_at(orig, 0, j);
            mat_set_val(&result, i, j, val);
        }
    }
    return result;
}

mat mat_add(mat a, mat b)
{
    /* NOTE(lucas): Matrices must be the same size in both dimensions,
     * or must be the same size in one dimension while one matrix is a row/column vector.
     * In the latter case, add the row/column vector across the matrix
     */
    b32 a_col_vec = a.cols == 1;
    b32 a_row_vec = a.rows == 1;
    b32 b_col_vec = b.cols == 1;
    b32 b_row_vec = b.rows == 1;
    b32 valid_sizes = ((a.rows == b.rows)       && (a.cols == b.cols))
                   || ((a_col_vec || b_col_vec) && (a.rows == b.rows))
                   || ((a_row_vec || b_row_vec) && (a.cols == b.cols));
    ASSERT(valid_sizes);

    // NOTE(lucas): If one matrix is a row/column vector and the other is not,
    // construct a new matrix of appropriate size by copying rows/columns
    if ((a.rows != b.rows) || (a.cols != b.cols))
    {
        if (b_row_vec)
            b = mat_stretch_rows(b, a);
        else if (b_col_vec)
            b = mat_stretch_cols(b, a);
        else if (a_row_vec)
            a = mat_stretch_cols(a, b);
        else if (a_col_vec)
            a = mat_stretch_cols(a, b);
    }

    mat result = mat_zeros(a.rows, a.cols);

    for (usize i = 0; i < result.rows; ++i)
    {
        for (usize j = 0; j < result.cols; ++j)
        {
            numeric val = mat_at(a, i, j) + mat_at(b, i, j);
            mat_set_val(&result, i, j, val);
        }
    }

    return result;
}

mat mat_mul(mat a, mat b)
{
    // For multiplication to be valid, the number of columns in A must equal the number of rows in B
    ASSERT(a.cols == b.rows);

    // Shape of output matrix is determined by the number of rows in A and the number of columns in B
    mat result = mat_zeros(a.rows, b.cols);

    // TODO(lucas): Replace this. This is the purely naive way to multiply matrices.
    for (usize i = 0; i < result.rows; ++i)
    {
        for (usize j = 0; j < result.cols; ++j)
        {
            numeric sum = 0;
            for (usize k = 0; k < a.cols; ++k)
                sum += mat_at(a, i, k) * mat_at(b, k, j);
            
            mat_set_val(&result, i, j, sum);
        }
    }
    return result;
}

mat mat_had(mat a, mat b)
{
    ASSERT(a.rows == b.rows);
    ASSERT(a.cols == b.cols);

    mat result = mat_zeros(a.rows, a.cols);

    for (usize row = 0; row < result.rows; ++row)
    {
        for (usize col = 0; col < result.cols; ++col)
        {
            numeric val = mat_at(a, row, col) * mat_at(b, row, col);
            mat_set_val(&result, row, col, val);
        }
    }

    return result;
}

@api_impl_end

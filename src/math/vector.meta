#include "../util/types.h"

#include <stdio.h>
#include <stdlib.h>

struct vec
{
    elements: usize;
    data: @array(elements) numeric;
};

/*
 * This is a multi-line comment.
 */

@api_iface_begin

vec vec_init(usize elements, numeric* data);
vec vec_zeros(usize elements);

// Create vector of a given size filled with fill_value
vec vec_full(usize elements, numeric fill_value);

// Set multiple vector values
void vec_set_range(vec* v, vec data, usize begin);

void vec_print(vec v);

vec vec_add(vec a, vec b);
vec vec_scale(vec v, numeric a);

// Element-wise (Hadamard product)
// Vectors must be equal size
vec vec_had(vec a, vec b);

@api_iface_end

@api_impl_begin

@inline numeric vec_at(vec v, usize index)
{
    numeric result = 0;
    result = v.data[index];
    return result;
}

vec vec_init(usize elements, numeric* data)
{
    vec result = {0};
    result.elements = elements;
    result.data = data;

    return result;
}

vec vec_zeros(usize elements)
{
    vec result = {0};
    result.elements = elements;

    result.data = calloc(elements, sizeof(numeric));
    ASSERT(result.data);

    return result;
}

vec vec_full(usize elements, numeric fill_value)
{
    vec v = vec_zeros(elements);

    for (usize i = 0; i < v.elements; ++i)
        v.data[i] = fill_value;

    return v;
}

void vec_set_range(vec* v, vec data, usize begin)
{
    // Ensure there is enough room in the vector
    ASSERT(v->elements >= data.elements + begin);

    for (usize i = 0; i < data.elements; ++i)
        v->data[begin+i] = data.data[i];
}

void vec_print(vec v)
{
    printf("[");
    for (usize i = 0; i < v.elements; ++i)
    {
        if (i != 0) printf(", ");
        printf("%num", v.data[i]);
    }
    printf("]\n");
}

vec vec_add(vec a, vec b)
{
    ASSERT(a.elements == b.elements);
    vec result = vec_zeros(a.elements);

    for (usize i = 0; i < result.elements; ++i)
        result.data[i] = a.data[i] + b.data[i];

    return result;
}

vec vec_scale(vec v, numeric a)
{
    vec result = vec_zeros(v.elements);

    for (usize i = 0; i < result.elements; ++i)
        result.data[i] = a*v.data[i];

    return result;
}

vec vec_had(vec a, vec b)
{
    ASSERT(a.elements == b.elements);
    vec result = vec_zeros(a.elements);

    for (usize i = 0; i < result.elements; ++i)
        result.data[i] = a.data[i]*b.data[i];

    return result;
}

@api_impl_end

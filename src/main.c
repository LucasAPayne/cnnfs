#include "datasets.h"
#include "dense_layer.h"
#include "math/cnnfs_math.h"
#include "util/rng.h"
#include "util/types.h"

#include <stdio.h> // getchar

/* TODO(lucas): Known Issues:
 * mat_full functions prototypes are not being generated by metaprogramming layer.
 * Multi-line comments in .meta files are having some of their newlines preserved in generated code.
 */

// TODO(lucas): Free matrix memory
// TODO(lucas): CUDA error checking
// TODO(lucas): Make tests for CUDA functions
/* TODO(lucas): Add function to send matrices/vectors to device, and add device property to matrices and vectors.
 * Use enum for device DEVICE_CPU, DEVICE_GPU.
 * Make a note for the future to add gpu_num as well to support multiple GPUs in the future.
 * Check what device each matrix/vector is on in every function, and require that they are on the same device.
 * Return an error when two things are on different devices. 
 * Make a function to transfer vectors and matrices across devices.
 */
// TODO(lucas): Device dispatch function that handles switch statement for picking device? If so, assert devices there.
// TODO(lucas): Add enums to metaprogramming
// TODO(lucas): Get CUDA process working with metaprogramming

// TODO(lucas): Make CUDA version of each matrix operation.
// TODO(lucas): Make CUDA version of each vector operation.

int main()
{
    rand_seed(123);

    f32 a_data[] = {1.0f, 2.0f,
                   3.0f, 4.0f};
    f32 b_data[] = {5.0f, 6.0f,
                    7.0f, 8.0f};

    // TODO(lucas): Determine what device data is on during initialization to determine if it needs to
    // be transferred based on the destination device.
    mat_f32 a = mat_f32_init(2, 2, a_data, DEVICE_GPU);
    mat_f32 b = mat_f32_init(2, 2, b_data, DEVICE_GPU);
    mat_f32 c = mat_f32_add(a, b);

    c = mat_f32_to(c, DEVICE_CPU);
    mat_f32_print(c);
    // mat_f32 data;
    // vec_u8 labels;

    // create_spiral_data(100, 3, &data, &labels);

    // dense_layer_f32 dense1 = dense_layer_f32_init(2, 3);
    // dense_layer_f32_forward(&dense1, data);
    // mat_f32_print(dense1.output);

    getchar();

    return 0;
}
